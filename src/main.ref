*$FROM LibraryEx
$EXTERN ArgList, LoadFile, Map, Trim;

*$FROM parser
$EXTERN R05-Parse-File;

*$FROM generator
$EXTERN R05-Generate-ToFile;

*$FROM Platform
$EXTERN PathSeparator, IsDirectorySeparator;


$ENTRY GO {
  = <Main <ArgList>>;
}

Main {
  (e.ProgName) ('@' e.Config) =
    <Main (e.ProgName) <LoadFile e.Config>>;

  (e.ProgName) e.Files =
    <FindFiles-SwFound <FindFiles-Default e.Files>>;
}

FindFiles-SwFound {
  e.Files-B (NotFound e.FileName) e.Files-E =
    <Map refal05c_PrintNotFound (NotFound e.FileName) e.Files-E>;

  e.FoundFiles =
    <CheckCompilationResult
      <Map refal05c_ProcessEachSource e.FoundFiles>
    >;
}

$ENTRY refal05c_PrintNotFound {
  (NotFound e.FileName) =
    <Prout 'COMMAND LINE ERROR: file ' e.FileName ' not found'>;

  (Output e.FileName) = ;

  (Source (e.Source) e.Output) = ;
}

$ENTRY refal05c_ProcessEachSource {
  (Output e.OutputName) =
    <Prout '+Linking ' e.OutputName> (e.OutputName);

  (Source (e.Source) e.OutputName) =
    <Prout '*Compiling ' e.Source ':'>
    <CompileSource-SwSuccessedParse
      (e.Source) (e.OutputName) <R05-Parse-File e.Source>
    >
}

CompileSource-SwSuccessedParse {
  (e.SrcName) (e.OutputName) Success e.Tree =
    <R05-Generate-ToFile (e.OutputName) e.Tree>
    (e.OutputName);

  (e.SrcName) (e.OutputName) Fails e.Errors =
    <Map (refal05c_WriteError e.SrcName) e.Errors>
    Fails;
}

$ENTRY refal05c_WriteError {
  e.FileName (t.SrcPos e.Message) =
    <Prout e.FileName ':' <StrFromSrcPos t.SrcPos> ':ERROR: ' e.Message>;
}

StrFromSrcPos {
  (s.Line s.Col e.FileName) = <Symb s.Line> ':' <Symb s.Col>;
}


CheckCompilationResult {
  e.Outputs-B Fails e.Outputs-E =
    <Prout '*** COMPILATION FAILED ***'>
    <Exit 1>;

  e.Outputs = <CheckRetcode <CCompile e.Outputs>>;
}

CheckRetcode {
  /* Не установлена R05CCOMP или компиляция прошла успешно */
  0 = <Prout '*** Compilation successed ***'>;

  e.RetCode =
    <Prout
      '*** COMPILATION FAILED '
      '(C COMPILER FAILED, RETCODE: ' <Symb e.RetCode>')***'
    >
    <Exit e.RetCode>;
}

LoadPath {
  = <ParsePath <GetEnv 'R05PATH'>>
    <ParsePath <GetEnv 'REF5RSL'>>
}

ParsePath {
  e.Folder s.Sep e.Path
    , <PathSeparator> : s.Sep
    = <ParseFolder e.Folder> <ParsePath e.Path>;
  e.Folder = <ParseFolder e.Folder>;
}

ParseFolder {
  e.Folder = <ParseFolder-CheckEmpty <Trim e.Folder>>;
}

ParseFolder-CheckEmpty {
  /* пусто */ = /* пусто */;
  e.Folder = (e.Folder);
}

FindFiles-Default {
  e.Files = <FindFiles (<LoadPath>) e.Files>;
}

FindFiles {
  (e.Folders) e.Files =
    <Map (findfile_AnalyzeFile-ByFolders Current e.Folders) e.Files>;
}

$ENTRY findfile_AnalyzeFile-ByFolders {
  e.Folders (e.FileName) =
    <AnalyzeFile-CheckNotFound
      (e.FileName)
      <Map (findfile_AnalyzeInFolder e.FileName) e.Folders>
    >;
}

$ENTRY findfile_AnalyzeInFolder {
  e.FileName Current = <AnalyzeFile e.FileName>;

  e.FileName (e.Folder) = <AnalyzeFile e.Folder '/' e.FileName>;
}

AnalyzeFile-CheckNotFound {
  (e.FileName) (Source (e.Source) e.Output) e.Variants =
    (Source (e.Source) e.Output);

  (e.FileName) (Output e.Output) e.Variants =
    (Output e.Output);

  (e.FileName) (NotFound e.NotFoundPath) e.Variants =
    <AnalyzeFile-CheckNotFound (e.FileName) e.Variants>;

  (e.FileName) = (NotFound e.FileName);
}

ExistFile-T {
  e.FileName = <ExistFile e.FileName> e.FileName;
}

AnalyzeFile {
  e.FileName '.ref' =
    <AnalyzeSource-CheckExist
      <ExistFile-T e.FileName '.ref'>
    >;

  e.FileName '.c' =
    <AnalyzeOutput-CheckExist
      <ExistFile-T e.FileName '.c'>
    >;

  e.FileName =
    <AnalyzeBoth-CheckExist
      (<ExistFile-T e.FileName '.ref'>) <ExistFile-T e.FileName '.c'>
    >;
}

AnalyzeSource-CheckExist {
  True e.UnitName '.ref'
     = (Source (e.UnitName '.ref') <CutFolder e.UnitName '.c'>);

  False e.SourceName = (NotFound e.SourceName);
}

AnalyzeOutput-CheckExist {
  True e.OutName = (Output e.OutName);

  False e.OutName = (NotFound e.OutName);
}

AnalyzeBoth-CheckExist {
  (True e.SoureName) s.Res e.OutName
    = (Source (e.SoureName) <CutFolder e.OutName>);

  (False e.SoureName) True e.OutName = (Output e.OutName);

  (False e.UnitName '.ref') False e.UnitName '.c' = (NotFound e.UnitName);
}

CutFolder {
  e.Folder s.Sep e.FileName, <IsDirectorySeparator s.Sep> : True
     = <CutFolder e.FileName>;

  e.FileName = e.FileName;
}


CCompile {
  e.CSources = <CCompile-SwSetEnv (<GetEnv 'R05CCOMP'>) e.CSources>;
}

CCompile-SwSetEnv {
  (/* не установлена R05CCOMP */) e.CSources = 0;

  (e.CommandLine) e.CSources =
    <System
      e.CommandLine ' ' <GetEnv 'R05CFLAGS'>
      <Map compilerutils_IncludeFlag <LoadPath>>
      <Map compilerutils_QuoteFile e.CSources>
    >;
}

$ENTRY compilerutils_IncludeFlag {
  (e.PathEntry) = ' -I"' e.PathEntry '"';
}

$ENTRY compilerutils_QuoteFile {
  (e.FileName) = ' "' e.FileName '"';
}
