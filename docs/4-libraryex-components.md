Библиотека `LibraryEx` и библиотека компонентов компилятора
===========================================================

В данном разделе будут рассмотрены исходные тексты, лежащие в каталоге `src`
дистрибутива Рефала-05. В частности, там располагается библиотека `LibraryEx`
с полезными вспомогательными функциями и интерфейсы исходных текстов компонентов
компилятора.

В библиотеке `LibraryEx` находится несколько полезных функций вроде функции
инкремента, загрузки всего содержимого текстового файла и набора функций высшего
порядка — функции мелкие и простые, но при этом сокращают набор кода и упрощают
программу.

Компилятор построен как набор повторно используемых компонент: синтаксического
дерева, лексического и синтаксического анализаторов, генератора кода и набора
утилитарных функций. Эти компоненты можно использовать как библиотеки при
написании других инструментальных средств для работы с Рефалом-05. Мотивация
такого подхода описана [в первом разделе](1-intro.md).

Все компоненты, рассматриваемые здесь, написаны на общем подмножестве Рефала-05
и Рефала-5, а это значит, что их можно использовать и при программировании
на Рефале-5 тоже. Более того, если для раскрутки компилятора использовался
Рефал-5, то скомпилированные `.rsl`-ки рассматриваемых библиотек лежат в папке
`bin`, а это значит, что её можно добавить в переменную `REF5RSL`. Об этом
говорилось в [разделе установки](3-install-and-usage.md), но повторить лишним
не будет.

**Интерфейс рассматриваемых библиотек может меняться в будущих версиях, что
не всегда будет вовремя отражаться в документации. Поэтому сверяйтесь
с комментариями в исходных текстах.**


Библиотека `LibraryEx`
----------------------

В отличие от библиотеки встроенных функций `Library`, библиотека `LibraryEx`
написана на Рефале без нативных вставок, а значит, принципиально новых
возможностей не несёт. Всё, что в ней есть — это надстройки над встроенными
функциями и другие функции, облегчающие программирование на Рефале.

Средства библиотеки можно условно разделить на две группы: утилитарные функции
и функции высшего порядка. Первые облегчают выполнение некоторых часто
встречающихся задач, вторые инкапсулируют циклы при обработке последовательностей
однородных термов. Поэтому рассмотрим их по отдельности.

**Примечание.** Есть одноимённая библиотека `LibraryEx` в Рефале-5λ, библиотека
Рефала-05 была написана на основе неё. В библиотеке Рефала-5λ имеется гораздо
больше функций, которые не были перенесены в Рефал-05 из соображений минимализма.
Кроме того, эти библиотеки **несовместимы в части функций высшего порядка** —
в Рефале-05 для косвенного вызова используется функция `Mu`, Рефал-5λ функцию
`Mu` не использует. Это надо иметь ввиду.


### Утилитарные функции

#### Пустые функции `Success` и `Fails`

    *$EENUM Success, Fails

Две пустые функции, часто используемые в исходных текстах компилятора как
признак успешного и неуспешного выполнения. Типичный формат функции,
использующей эти признаки:

    <SomeFunc e.SomeArgs>
      == Success e.SuccessfulResult
      == Fails e.ErrorInfo

#### Функция `LoadFile`

    <LoadFile e.FileName> == e.Lines

    e.Lines ::= (e.Line)*
    e.Line ::= s.CHAR*

Функция загружает содержимого текстового файла с заданным именем как
последовательность строк. Функция одинаково корректно работает с файлами,
последняя строка которых как заканчивается на символ перевода строки,
так и не заканчивается. Первый случай некоторые текстовые редакторы трактуют
как пустую строку в конце — функция `LoadFile` пустую строку в конец
не добавляет.

Функция использует дескриптор файла 39.

#### Функция `SaveFile`

    <SaveFile (e.FileName) e.Lines>

Функция сохраняет последовательность строк как новый текстовый файл с заданным
именем. Если файл с таким именем уже был — он перезаписывается. В конец
последней строки всегда добавляется символ перевода строки, что может
трактоваться некоторыми текстовыми редакторами как лишняя пустая строчка
в конце.

Функция использует дескриптор файла 39.

#### Функция `Inc` и `Dec`

    <Inc s.NUMBER> == s.NUMBER
    <Dec s.NUMBER> == s.NUMBER

Функции, соответственно, вычисляют значение на единицу большее и меньшее своего
аргумента. Запись `<Inc s.X>` компактнее, чем `<Add s.X 1>`, поэтому они
добавлены в библиотеку.

#### Функция `ArgList`

    <ArgList> == (e.Arg)+
    e.Arg ::= s.CHAR*

Возвращает список аргументов командной строки. Первый скобочный терм — имя
запущенной программы. Поскольку встроенная функция `Arg` не может отличить
пустой аргумент от последнего (при обращении к аргументу с номером, большим,
чем последний, возвращается пустая строка), функция `ArgList` перечисляет
аргументы до первого пустого.

#### Функция `Trim`

    <Trim s.CHAR*> == s.CHAR*

Отбрасывает символы пустого пространства от начала и конца строки. К символам
пустого пространства относятся пробелы, табуляции (`\t`), возвраты каретки
(`\r`) и переводы строк (`\n`).


### Функции высшего порядка

#### Замыкание (`t.Closure`), функция `Apply`

    t.Closure ::=
        s.FUNCTION
      | (t.Closure e.Bounded)

    <Apply t.Closure e.Arg> == e.Res

    e.Bounded, e.Arg, e.Res ::= e.AnyExpr

Все функции высшего порядка принимают объект «замыкание», который может быть
либо символом функции, либо каррированной функцией. Каррированная функция
представляет собой скобочный терм, первым термом содержимого которого является
другое замыкание, остальная часть — связанный аргумент.

Например, `(Add 3)` — замыкание, в котором функция сложения связана с первым
аргументом. `(Map (Add 3))` — функция, которая принимает последовательность
чисел и к каждому прибавляет 3 (функция `Map` чуть ниже по тексту).

Для вызова замыкания используется функция `Apply`:

    <Apply Add 1 2>                   → 3
    <Apply (Add 3) 10>                → 13
    <Apply (Map (Add 3)) 100 200 300> → 103 203 303

Функция `Apply` для вызова замыкания использует `Mu`. Остальные функции
высшего порядка используют уже `Apply` для вызова замыканий, а значит, косвенно
используют `Mu`. Детали использования `Mu` в общем подмножестве рассмотрены
[во втором разделе](2-syntax.md).

**Примечание.** В Рефале-5λ все функции высшего порядка библиотеки `LibraryEx`
тоже используют `Apply`, но функция `Apply` не использует `Mu`. Поэтому
в функции высшего порядка там можно передавать только символы-функции, которые
графически отличаются от символов-функций Рефала-05, поскольку начинаются с `&`.

Поэтому, если используете Рефал-5λ для компиляции исходников, написанных для
Рефала-05, следует использовать библиотеку `LibraryEx` Рефала-05.

#### Функция `Map`

    <Map t.Closure t.Item*> == e.ItemRes*

    <Apply t.Closure t.Item> == e.ItemRes

Функция применяет `t.Closure` к `t.Item*` слева-направо. Заметим, что в отличие
от других языков программирования, функция `Map` в Рефале более универсальна.
Замыкание может не возвращать никакое значение (возвращать пустую строку),
и в итоге весь вызов `Map` будет возвращать пустоту. Функция `Map` также может
осуществлять фильтрацию, если замыкание возвращает либо свой аргумент как есть,
если терм «подходит», либо возвращает пустую строку, если терм «не подходит».

**Пример.** Преобразование каждого числа в строковую форму с добавлением
точки с запятой в конце:

    /*
      <CSVLine s.NUMBER*> == s.CHAR*
    */
    CSVLine {
      e.Numbers = <Map map_example_FormatNumber e.Numbers>;
    }

    $ENTRY map_example_FormatNumbers {
      s.Number = <Symb s.Number> ';';
    }

Функция распечатывает строчки чисел по одной на строке

    /*
      <CSVTable (s.NUMBER*)*> == пусто
    */
    CSVTable {
      e.Lines = <Map map_example_PutLine e.Lines>;
    }

    $ENTRY map_example_PutLine {
      (e.Numbers) = <Prout <CSVLine e.Numbers>>;
    }

Функция удаляет пустые строки:

    /*
      <RemoveEmpty e.Lines> == e.Lines
      e.Lines ::= (s.CHAR*)*
    */
    RemoveEmpty {
      e.Lines = <Map map_example_CheckEmpty e.Lines>;
    }

    $ENTRY map_example_CheckEmpty {
      (/* пусто */) = /* пропускаем */;

      (e.Line) = (e.Line); /* оставляем */
    }

### Функция `Reduce`

    <Reduce t.Closure t.Accum t.Item*> == t.Accum′

    <Apply t.Closure t.Accum t.Item> == t.Accum′
    t.Accum′ ::= t.Accum

Функция реализует левую свёртку, т.е. применяет замыкание `t.Closure` к паре
из аккумулятора `t.Accum` и очередного терма `t.Item` слева-направо, результат
выполнения замыкания должен быть ровно одним термом — новым значением
аккумулятора. Если замыкание возвращает не один терм (а, например, пустую строку
или несколько термов), поведение функции не определено. Возвращаемое значение —
аккумулятор после свёртки последнего терма.

**Пример.** Хеш-функция:

    /*
      <Hash s.Value*> == s.NUMBER
      s.Value ::= s.NUMBER | s.CHAR
    */
    Hash {
      e.InputString = <Reduce reduce_example_HashOne 43 <Ord e.InputString>;
    }

    $ENTRY reduce_example_HashOne {
      s.Hash s.Number = <Add <Mul s.Hash 37> s.Number>;
    }

#### Функция `MapAccum`

    <MapAccum t.Closure t.Accum t.Item*> == t.Accum′ e.ItemRes*

    <Apply t.Closure t.Accum t.Item> == t.Accum′ e.ItemRes
    t.Accum′ ::= t.Accum

Функция применяет замыкание `t.Closure` к каждому терму из `t.Item*`
с использованием состояния, сохранённого в аккумуляторе `t.Accum`. Возвращаемое
значение замыкания — новое содержимое аккумулятора и результат преобразования
очередного терма. Результат всей функции — последнее значение аккумулятора
и конкатенация результатов трансформации термов.

**Пример.** Функция, которая отделяет ангцев от козлищ.

    *$ENUM Lamb /* агнец */, Goat /* козлище */

    /*
      <Separate t.Animal*> == (t.Lamb*) t.Goat*
      t.Animal ::=
          (Lamb t.Lamb)
        | (Goat t.Goat)
    */
    Separate {
      e.Animals =
        <MapAccum mapaccum_example_Separate (/* lambs */) e.Animals>;
    }

    $ENTRY mapaccum_example_Separate {
      (e.Lambs) (Lamb t.Lamb) = (e.Lambs t.Lamb) /* пусто */;

      (e.Lambs) (Goat t.Goat) = (e.Lambs) t.Goat;
    }

Здесь функция `mapaccum_example_Separate` кладёт ягнёнка в аккумулятор
и оставляет пустоту как результат преобразования. Козла же в аккумулятор она
не кладёт, оставляя его как результат. В итоге после завершения перебора
в аккумуляторе остаются ягнята, козлы остаются снаружи.

Другой пример в функции `DelAccumulator`.

#### Функция `DelAccumulator`

    <DelAccumulator t.Accum e.AnyExpr> == e.AnyExpr

Просто отбрасывает первый терм от выражения. Используется в сочетании
с `MapAccum`, если последнее значение аккумулятора не нужно, он использовался
ради побочного эффекта.

Формально это, конечно, функция первого порядка, но она предназначена для
совместного использования с функцией `MapAccum`, поэтому рассматривается
в этом подразделе.

**Пример.** Функция, которая добавляет номер в начало каждой строки.

    /*
      <Enumerate (e.Line)*> == (s.NUMBER e.Line)*
    */
    Enumerate {
      e.Lines =
        <DelAccumulator
          <MapAccum mapaccum_example_AddNumber 1 e.Lines>
        >;
    }

    $ENTRY mapaccum_example_AddNumber {
      s.LineNo (e.Line) = <Inc s.LineNo> (s.LineNo e.Line);
    }

После завершения прохода по строкам функция `MapAccum` оставит в поле зрения
пронумерованные строки и число, на единицу большее номера последней строки. Это
число не нужно, его отбрасываем при помощи `DelAccumulator`.
